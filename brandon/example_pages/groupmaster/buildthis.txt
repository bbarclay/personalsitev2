Below is a fully debugged TypeScript React component (`.tsx`) file for a new game called **GroupMaster**, designed to teach concepts of group theory (a branch of abstract algebra) through an interactive, puzzle-solving experience. This game maintains the complexity and length of the previous examples but introduces a unique theme of exploring mathematical "realms" where players solve group operation puzzles, unlock new group structures, and upgrade their "Mathematical Tools." The game uses TypeScript for type safety and includes a grid-based minigame to explore group properties like closure and identity.

### Game Overview: GroupMaster
- **Theme:** Players are "Mathematicians" exploring "Realms" of group theory, solving puzzles based on group operations (e.g., addition modulo n, symmetry groups).
- **Mathematical Concept:** Group theory basics—closure, associativity, identity, and inverses—taught through interactive challenges.
- **Structure:** Four realms, each representing a different group (e.g., Z/4Z, Klein Four-Group), with puzzles requiring players to complete operation tables or find properties.
- **Minigame:** A grid where players place elements to satisfy group axioms, balancing "insight" (energy) and avoiding "fallacies" (errors).
- **Progression:** Earn "Theorems" (reputation) and "Proofs" (credits) to unlock realms and upgrade tools like "Closure Checker" or "Inverse Finder."

### Implementation

```tsx
import React, { useState, useEffect, useCallback } from 'react';

const GroupMaster: React.FC = () => {
  // Core state with TypeScript types
  const [darkMode, setDarkMode] = useState<boolean>(true);
  const [gameStarted, setGameStarted] = useState<boolean>(false);
  const [activeRealm, setActiveRealm] = useState<number>(0);
  const [theorems, setTheorems] = useState<number>(0);
  const [proofs, setProofs] = useState<number>(0);
  const [username, setUsername] = useState<string>('');
  const [avatar, setAvatar] = useState<string>('scholar');
  const [insight, setInsight] = useState<number>(100);
  const [puzzleActive, setPuzzleActive] = useState<boolean>(false);
  const [currentPuzzle, setCurrentPuzzle] = useState<Puzzle | null>(null);
  const [puzzleGrid, setPuzzleGrid] = useState<GridCell[][]>([]);
  const [gridSize] = useState<number>(4);
  const [selectedCell, setSelectedCell] = useState<{ row: number; col: number } | null>(null);

  // UI state
  const [showTerminal, setShowTerminal] = useState<boolean>(false);
  const [terminalInput, setTerminalInput] = useState<string>('');
  const [terminalHistory, setTerminalHistory] = useState<TerminalEntry[]>([
    { timestamp: getCurrentTime(), text: 'GroupMaster v1.0 initialized...' },
    { timestamp: getCurrentTime(), text: 'Type "help" for commands.' },
  ]);
  const [showNotification, setShowNotification] = useState<boolean>(false);
  const [notificationMessage, setNotificationMessage] = useState<string>('');
  const [showTutorial, setShowTutorial] = useState<boolean>(true);
  const [tutorialStep, setTutorialStep] = useState<number>(0);
  const [showGlitchEffect, setShowGlitchEffect] = useState<boolean>(false);

  // Game state
  const [realmsVisited, setRealmsVisited] = useState<number[]>([0]);
  const [puzzleTimeout, setPuzzleTimeout] = useState<NodeJS.Timeout | null>(null);

  // Types for game entities
  interface Tool {
    id: string;
    name: string;
    level: number;
    description: string;
    unlocked: boolean;
    cost: number;
  }

  interface Achievement {
    id: string;
    name: string;
    description: string;
    unlocked: boolean;
  }

  interface Puzzle {
    id: string;
    name: string;
    type: 'closure' | 'identity' | 'inverse' | 'table';
    difficulty: string;
    theoremReward: number;
    proofReward: number;
    insightRequired: number;
    completed: boolean;
  }

  interface GridCell {
    value: string;
    correct: boolean;
    revealed: boolean;
  }

  interface TerminalEntry {
    timestamp: string;
    text: string;
    isCommand?: boolean;
  }

  // Mathematical Tools
  const [tools, setTools] = useState<Tool[]>([
    { id: 'closure', name: 'Closure Checker', level: 1, description: 'Verifies closure property', unlocked: true, cost: 100 },
    { id: 'identity', name: 'Identity Finder', level: 1, description: 'Locates identity elements', unlocked: false, cost: 150 },
    { id: 'inverse', name: 'Inverse Solver', level: 1, description: 'Finds inverses in groups', unlocked: false, cost: 150 },
    { id: 'associativity', name: 'Assoc. Prover', level: 1, description: 'Checks associativity', unlocked: false, cost: 200 },
  ]);

  // Achievements
  const [achievements, setAchievements] = useState<Achievement[]>([
    { id: 'first_proof', name: 'First Theorem', description: 'Solve your first puzzle', unlocked: false },
    { id: 'realm_master', name: 'Realm Master', description: 'Explore all realms', unlocked: false },
    { id: 'tool_expert', name: 'Tool Expert', description: 'Unlock all tools', unlocked: false },
    { id: 'group_legend', name: 'Group Legend', description: 'Reach 100 theorems', unlocked: false },
  ]);

  // Realms (Groups)
  const realms = [
    { name: 'Z/4Z', color: '#ff6f61', description: 'Cyclic group under addition mod 4.', icon: '🔢', theoremsRequired: 0 },
    { name: 'Klein Four', color: '#6b5b95', description: 'Non-cyclic abelian group.', icon: '🔲', theoremsRequired: 30 },
    { name: 'S3', color: '#88b04b', description: 'Symmetric group on 3 elements.', icon: '🔄', theoremsRequired: 60 },
    { name: 'Z/6Z', color: '#ffa500', description: 'Cyclic group under addition mod 6.', icon: '🔆', theoremsRequired: 90 },
  ];

  // Puzzles for each realm
  const [puzzles, setPuzzles] = useState<Puzzle[][]>([
    // Z/4Z
    [
      { id: 'closure_1', name: 'Closure Test', type: 'closure', difficulty: 'Easy', theoremReward: 10, proofReward: 50, insightRequired: 20, completed: false },
      { id: 'identity_1', name: 'Identity Hunt', type: 'identity', difficulty: 'Medium', theoremReward: 20, proofReward: 100, insightRequired: 30, completed: false },
    ],
    // Klein Four
    [
      { id: 'inverse_1', name: 'Inverse Search', type: 'inverse', difficulty: 'Medium', theoremReward: 30, proofReward: 150, insightRequired: 40, completed: false },
      { id: 'table_1', name: 'Table Completion', type: 'table', difficulty: 'Hard', theoremReward: 40, proofReward: 200, insightRequired: 50, completed: false },
    ],
    // S3
    [
      { id: 'closure_2', name: 'Closure Proof', type: 'closure', difficulty: 'Hard', theoremReward: 50, proofReward: 250, insightRequired: 60, completed: false },
      { id: 'identity_2', name: 'Identity Check', type: 'identity', difficulty: 'Very Hard', theoremReward: 60, proofReward: 300, insightRequired: 70, completed: false },
    ],
    // Z/6Z
    [
      { id: 'inverse_2', name: 'Inverse Mastery', type: 'inverse', difficulty: 'Very Hard', theoremReward: 70, proofReward: 350, insightRequired: 80, completed: false },
      { id: 'table_2', name: 'Full Table', type: 'table', difficulty: 'Extreme', theoremReward: 100, proofReward: 500, insightRequired: 90, completed: false },
    ],
  ]);

  // Group theory tips
  const groupTips = [
    'A group must be closed under its operation.',
    'Every group has an identity element.',
    'Each element in a group has an inverse.',
    'Group operations are associative.',
    'Finite groups have a specific order.',
    'Cyclic groups are generated by a single element.',
    'Check the operation table for group properties.',
    'Inverses undo the effect of an operation.',
    'The identity element leaves others unchanged.',
    'Subgroups must satisfy all group axioms.',
  ];

  // Tutorial steps
  const tutorialSteps = [
    { text: 'Welcome to GroupMaster, Mathematician. I’m your AI guide.', character: 'ai' },
    { text: 'Prove theorems by solving group theory puzzles to gain insight.', character: 'ai' },
    { text: 'Start in Z/4Z, then unlock more complex group realms.', character: 'ai' },
    { text: 'Upgrade your tools to tackle harder puzzles efficiently.', character: 'ai' },
    { text: 'Ready to explore the world of groups? Enter your name to begin.', character: 'ai' },
  ];

  // Background geometric patterns
  const patterns = Array.from({ length: 15 }, (_, i) => ({
    id: i,
    top: Math.random() * 100,
    left: Math.random() * 100,
    size: Math.random() * 30 + 10,
    opacity: Math.random() * 0.3 + 0.1,
    rotation: Math.random() * 360,
  }));

  // Initialize puzzle grid
  useEffect(() => {
    if (currentPuzzle) {
      generatePuzzleGrid();
      setInsight(100);
    }
  }, [currentPuzzle]);

  // Track visited realms
  useEffect(() => {
    if (!realmsVisited.includes(activeRealm)) {
      setRealmsVisited([...realmsVisited, activeRealm]);
      setTheorems((prev) => prev + 5);
      showNotificationMessage(`Explored ${realms[activeRealm].name}! +5 theorems`);
      if (realmsVisited.length + 1 === realms.length) {
        unlockAchievement('realm_master');
      }
    }
  }, [activeRealm]);

  // Check tool unlocks
  useEffect(() => {
    checkToolUnlocks();
  }, [theorems]);

  // Rotate tips
  const [currentTip, setCurrentTip] = useState<number>(0);
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentTip((prev) => (prev + 1) % groupTips.length);
    }, 15000);
    return () => clearInterval(interval);
  }, []);

  // Utility functions
  function getCurrentTime(): string {
    return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }

  function getDifficultyLevel(difficulty: string): number {
    const levels: { [key: string]: number } = { Easy: 1, Medium: 2, Hard: 3, 'Very Hard': 4, Extreme: 5 };
    return levels[difficulty] || 1;
  }

  function generatePuzzleGrid(): void {
    if (!currentPuzzle) return;
    const difficulty = getDifficultyLevel(currentPuzzle.difficulty);
    const newGrid: GridCell[][] = Array(gridSize)
      .fill(null)
      .map(() => Array(gridSize).fill({ value: '?', correct: false, revealed: false }));

    // Define group elements based on realm
    const elements: string[] = activeRealm === 0 ? ['0', '1', '2', '3'] : // Z/4Z
                              activeRealm === 1 ? ['e', 'a', 'b', 'c'] : // Klein Four
                              activeRealm === 2 ? ['e', 'r', 'r²', 's', 'sr', 'sr²'] : // S3
                              ['0', '1', '2', '3', '4', '5']; // Z/6Z

    // Populate grid based on puzzle type
    if (currentPuzzle.type === 'closure') {
      for (let i = 0; i < difficulty * 2; i++) {
        const row = Math.floor(Math.random() * gridSize);
        const col = Math.floor(Math.random() * gridSize);
        newGrid[row][col] = { value: elements[Math.floor(Math.random() * elements.length)], correct: true, revealed: false };
      }
    } else if (currentPuzzle.type === 'identity') {
      const identity = activeRealm === 0 || activeRealm === 3 ? '0' : 'e';
      const row = Math.floor(Math.random() * gridSize);
      const col = Math.floor(Math.random() * gridSize);
      newGrid[row][col] = { value: identity, correct: true, revealed: false };
    } else if (currentPuzzle.type === 'inverse') {
      const element = elements[Math.floor(Math.random() * (elements.length - 1)) + 1];
      const inverse = activeRealm === 0 ? `${(4 - parseInt(element)) % 4}` :
                      activeRealm === 3 ? `${(6 - parseInt(element)) % 6}` :
                      element === 'a' ? 'a' : element === 'b' ? 'b' : element === 'c' ? 'c' :
                      element === 'r' ? 'r²' : element === 'r²' ? 'r' : element === 's' ? 's' : 'sr';
      newGrid[Math.floor(Math.random() * gridSize)][Math.floor(Math.random() * gridSize)] = { value: element, correct: false, revealed: false };
      newGrid[Math.floor(Math.random() * gridSize)][Math.floor(Math.random() * gridSize)] = { value: inverse, correct: true, revealed: false };
    } else if (currentPuzzle.type === 'table') {
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (activeRealm === 0) {
            newGrid[i][j] = { value: `${(i + j) % 4}`, correct: true, revealed: Math.random() > 0.5 };
          } // Simplified for Z/4Z
        }
      }
    }

    setPuzzleGrid(newGrid);
  }

  // Game mechanics
  const toggleTheme = (): void => setDarkMode(!darkMode);

  const startGame = (): void => {
    if (username.trim() === '') {
      showNotificationMessage('Enter your mathematician name to begin.');
      return;
    }
    setGameStarted(true);
    setTheorems(10);
    setProofs(50);
    showNotificationMessage('Mathematical journey commenced.');
    addTerminalEntry('System initialized. Welcome to group theory.');
    addTerminalEntry(`Greetings, ${username}. Z/4Z realm unlocked.`);
  };

  const selectAvatar = (type: string): void => setAvatar(type);

  const showNotificationMessage = (message: string): void => {
    setNotificationMessage(message);
    setShowNotification(true);
    setTimeout(() => setShowNotification(false), 3000);
  };

  const unlockAchievement = (id: string): void => {
    const updatedAchievements = achievements.map((a) =>
      a.id === id ? { ...a, unlocked: true } : a
    );
    if (!achievements.find((a) => a.id === id)!.unlocked) {
      setAchievements(updatedAchievements);
      showNotificationMessage(`Achievement Unlocked: ${achievements.find((a) => a.id === id)!.name}`);
      setTheorems((prev) => prev + 10);
      triggerGlitchEffect();
    }
    if (id !== 'group_legend' && theorems >= 100) {
      unlockAchievement('group_legend');
    }
  };

  const checkToolUnlocks = (): void => {
    const updatedTools = [...tools];
    let changed = false;

    if (theorems >= 20 && !updatedTools[1].unlocked) {
      updatedTools[1].unlocked = true;
      showNotificationMessage('Identity Finder unlocked!');
      changed = true;
    }
    if (theorems >= 40 && !updatedTools[2].unlocked) {
      updatedTools[2].unlocked = true;
      showNotificationMessage('Inverse Solver unlocked!');
      changed = true;
    }
    if (theorems >= 60 && !updatedTools[3].unlocked) {
      updatedTools[3].unlocked = true;
      showNotificationMessage('Assoc. Prover unlocked!');
      changed = true;
    }

    if (changed) {
      setTools(updatedTools);
      if (updatedTools.every((t) => t.unlocked)) {
        unlockAchievement('tool_expert');
      }
    }
  };

  const addTerminalEntry = (text: string): void => {
    setTerminalHistory((prev) => [...prev, { timestamp: getCurrentTime(), text }]);
  };

  const handleTerminalCommand = useCallback((): void => {
    if (!terminalInput.trim()) return;
    const command = terminalInput.trim().toLowerCase();
    setTerminalHistory((prev) => [...prev, { timestamp: getCurrentTime(), text: `> ${terminalInput}`, isCommand: true }]);

    switch (command) {
      case 'help':
        addTerminalEntry('Commands: help, clear, status, tools, puzzles, exit');
        break;
      case 'clear':
        setTerminalHistory([{ timestamp: getCurrentTime(), text: 'Terminal cleared.' }]);
        break;
      case 'status':
        addTerminalEntry(`Mathematician: ${username} | Theorems: ${theorems} | Proofs: ${proofs}`);
        addTerminalEntry(`Realm: ${realms[activeRealm].name} | Insight: ${insight}`);
        break;
      case 'tools':
        addTerminalEntry('Mathematical Tools:');
        tools.forEach((t) => t.unlocked && addTerminalEntry(`· ${t.name} (Lvl ${t.level}): ${t.description}`));
        break;
      case 'puzzles':
        addTerminalEntry(`Puzzles in ${realms[activeRealm].name}:`);
        puzzles[activeRealm].forEach((p, i) =>
          addTerminalEntry(`${i + 1}. ${p.name} - ${p.difficulty} [${p.completed ? 'SOLVED' : 'AVAILABLE'}]`)
        );
        break;
      case 'exit':
        setShowTerminal(false);
        break;
      default:
        if (command.startsWith('solve ')) {
          const target = command.substring(6);
          const puzzle = puzzles[activeRealm].find((p) =>
            p.name.toLowerCase().includes(target) || p.id.toLowerCase().includes(target)
          );
          if (puzzle) {
            if (puzzle.completed) {
              addTerminalEntry(`Puzzle already solved: ${puzzle.name}`);
            } else if (puzzle.insightRequired > insight) {
              addTerminalEntry(`Insufficient insight for ${puzzle.name}`);
            } else {
              addTerminalEntry(`Solving puzzle: ${puzzle.name}`);
              startPuzzle(puzzle);
            }
          } else {
            addTerminalEntry(`Puzzle not found: ${target}`);
          }
        } else {
          addTerminalEntry(`Unknown command: ${command}`);
        }
    }
    setTerminalInput('');
  }, [terminalInput, activeRealm, username, theorems, proofs, insight, puzzles, tools]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Enter' && showTerminal) handleTerminalCommand();
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleTerminalCommand, showTerminal]);

  const startPuzzle = (puzzle: Puzzle): void => {
    setCurrentPuzzle(puzzle);
    setPuzzleActive(true);
    const timeLimit = 30 + getDifficultyLevel(puzzle.difficulty) * 10;
    if (puzzleTimeout) clearTimeout(puzzleTimeout);
    const timeout = setTimeout(() => {
      if (puzzleActive) {
        setPuzzleActive(false);
        showNotificationMessage('Puzzle timed out!');
        addTerminalEntry('Puzzle failed: Time limit exceeded.');
        triggerGlitchEffect();
      }
    }, timeLimit * 1000);
    setPuzzleTimeout(timeout);
  };

  const completePuzzle = (puzzle: Puzzle): void => {
    const updatedPuzzles = [...puzzles];
    updatedPuzzles[activeRealm] = puzzles[activeRealm].map((p) =>
      p.id === puzzle.id ? { ...p, completed: true } : p
    );
    setPuzzles(updatedPuzzles);
    setTheorems((prev) => prev + puzzle.theoremReward);
    setProofs((prev) => prev + puzzle.proofReward);
    setPuzzleActive(false);
    setCurrentPuzzle(null);
    if (puzzleTimeout) {
      clearTimeout(puzzleTimeout);
      setPuzzleTimeout(null);
    }
    showNotificationMessage(`Puzzle Solved! +${puzzle.theoremReward} Theorems, +${puzzle.proofReward} Proofs`);
    addTerminalEntry(`Puzzle completed: ${puzzle.name}`);
    if (!achievements.find((a) => a.id === 'first_proof')!.unlocked) {
      unlockAchievement('first_proof');
    }
  };

  const handleGridInteraction = (row: number, col: number): void => {
    if (!puzzleActive || insight <= 0 || !currentPuzzle) return;
    setSelectedCell({ row, col });

    const newGrid = [...puzzleGrid];
    const cell = newGrid[row][col];
    const toolLevel = tools.find((t) => t.id === currentPuzzle.type)?.level || 1;
    const insightCost = 10 / toolLevel;

    if (!cell.revealed) {
      cell.revealed = true;
      setInsight((prev) => Math.max(0, prev - insightCost));
      if (cell.correct) {
        showNotificationMessage('Correct element placed!');
        if (allCorrectCellsRevealed(newGrid)) {
          completePuzzle(currentPuzzle);
        }
      } else {
        showNotificationMessage('Fallacy detected!');
        setInsight((prev) => Math.max(0, prev - 20));
      }
    }

    setPuzzleGrid(newGrid);
    if (insight - insightCost <= 0) {
      setPuzzleActive(false);
      showNotificationMessage('Out of insight! Puzzle failed.');
      addTerminalEntry('Puzzle failed: Insight depleted.');
    }
  };

  const allCorrectCellsRevealed = (grid: GridCell[][]): boolean => {
    return grid.flat().filter((cell) => cell.correct).every((cell) => cell.revealed);
  };

  const upgradeTool = (id: string): void => {
    const tool = tools.find((t) => t.id === id);
    if (!tool || !tool.unlocked || proofs < tool.cost * tool.level) {
      showNotificationMessage(`Not enough proofs to upgrade ${tool!.name}`);
      return;
    }
    setTools((prev) =>
      prev.map((t) => (t.id === id ? { ...t, level: t.level + 1 } : t))
    );
    setProofs((prev) => prev - tool.cost * tool.level);
    showNotificationMessage(`${tool.name} upgraded to level ${tool.level + 1}`);
    addTerminalEntry(`Tool ${tool.name} upgraded to level ${tool.level + 1}`);
  };

  const nextTutorialStep = (): void => {
    if (tutorialStep < tutorialSteps.length - 1) {
      setTutorialStep(tutorialStep + 1);
    } else {
      setShowTutorial(false);
    }
  };

  const triggerGlitchEffect = (): void => {
    setShowGlitchEffect(true);
    setTimeout(() => setShowGlitchEffect(false), 1000);
  };

  // UI Components
  const renderAvatar = (type: string, size: number = 40): JSX.Element => {
    const avatars: { [key: string]: string } = {
      scholar: '🧑‍🏫',
      robot: '🤖',
      book: '📘',
      equation: '➗',
    };
    return (
      <div
        style={{
          width: `${size}px`,
          height: `${size}px`,
          borderRadius: '50%',
          backgroundColor: darkMode ? '#1a2a1a' : '#e0e0e0',
          border: `2px solid ${type === avatar ? '#ff6f61' : 'transparent'}`,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: `${size / 2}px`,
          cursor: 'pointer',
          transition: 'all 0.2s ease',
          opacity: type === avatar ? 1 : 0.7,
        }}
        onClick={() => selectAvatar(type)}
        className={type === avatar ? 'pulse-glow' : ''}
      >
        {avatars[type]}
      </div>
    );
  };

  return (
    <div
      style={{
        fontFamily: "'Roboto Mono', monospace",
        minHeight: '100vh',
        backgroundColor: darkMode ? '#0a1a0a' : '#f0f0f0',
        color: darkMode ? '#ff6f61' : '#121212',
        transition: 'background-color 0.3s, color 0.3s',
        position: 'relative',
        overflow: 'hidden',
        backgroundImage: darkMode ? 'linear-gradient(45deg, rgba(20,10,0,0.2) 0%, rgba(0,20,0,0.2) 100%)' : 'none',
      }}
    >
      {/* CSS Styling */}
      <style jsx>{`
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap');

        @keyframes pulse-glow {
          0%, 100% { box-shadow: 0 0 5px #ff6f61; }
          50% { box-shadow: 0 0 20px #ff6f61; }
        }

        @keyframes pattern-spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }

        @keyframes terminal-cursor {
          0%, 100% { opacity: 1; }
          50% { opacity: 0; }
        }

        @keyframes glitch {
          0% { transform: translate(0); text-shadow: -2px 0 #ff6f61, 2px 0 #88b04b; }
          20% { transform: translate(-3px, 3px); text-shadow: 2px 0 #ff6f61, -2px 0 #88b04b; }
          40% { transform: translate(-3px, -3px); text-shadow: 2px 0 #88b04b, -2px 0 #ff6f61; }
          60% { transform: translate(3px, 3px); text-shadow: -2px 0 #88b04b, 2px 0 #ff6f61; }
          80% { transform: translate(3px, -3px); text-shadow: -2px 0 #ff6f61, 2px 0 #88b04b; }
          100% { transform: translate(0); text-shadow: -2px 0 #ff6f61, 2px 0 #88b04b; }
        }

        .glitch { animation: glitch 0.3s infinite; }
        .pulse-glow { animation: pulse-glow 2s infinite; }
        .pattern-spin { animation: pattern-spin 20s linear infinite; }
        .terminal-cursor { animation: terminal-cursor 1s infinite; }

        .hover-effect:hover {
          text-shadow: 0 0 8px #ff6f61;
          transform: scale(1.05);
          transition: all 0.2s ease;
        }

        .grid-cell {
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          border: 1px solid #333;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 16px;
        }

        .grid-cell:hover {
          transform: scale(1.1);
          box-shadow: 0 0 8px rgba(255, 111, 97, 0.5);
        }

        .progress-bar {
          height: 8px;
          border-radius: 4px;
          overflow: hidden;
          background-color: rgba(255, 255, 255, 0.1);
        }

        .progress-bar-fill {
          height: 100%;
          transition: width 0.3s ease;
        }

        .puzzle-grid {
          display: grid;
          grid-template-columns: repeat(${gridSize}, 40px);
          gap: 2px;
        }

        .terminal-window {
          background-color: rgba(0, 20, 0, 0.9);
          color: #ff6f61;
          border: 1px solid #ff6f61;
          border-radius: 4px;
          padding: 1rem;
          overflow-y: auto;
          max-height: 400px;
        }

        .terminal-input {
          background-color: transparent;
          border: none;
          border-bottom: 1px solid #ff6f61;
          color: #ff6f61;
          font-family: 'Roboto Mono', monospace;
          padding: 0.5rem;
          width: 100%;
          outline: none;
        }

        .terminal-input:focus {
          box-shadow: 0 0 5px rgba(255, 111, 97, 0.5);
        }

        .neo-button {
          background-color: rgba(0, 20, 0, 0.8);
          color: #ff6f61;
          border: 1px solid #ff6f61;
          padding: 0.5rem 1rem;
          font-family: 'Roboto Mono', monospace;
          cursor: pointer;
          transition: all 0.2s ease;
          text-transform: uppercase;
        }

        .neo-button:hover {
          background-color: rgba(255, 111, 97, 0.1);
          box-shadow: 0 0 10px rgba(255, 111, 97, 0.5);
        }

        .neo-button:active {
          transform: translateY(2px);
        }

        .neo-card {
          background-color: rgba(0, 20, 0, 0.8);
          border: 1px solid #ff6f61;
          border-radius: 4px;
          padding: 1rem;
          margin-bottom: 1rem;
          box-shadow: 0 0 10px rgba(255, 111, 97, 0.2);
          transition: all 0.2s ease;
        }

        .neo-card:hover {
          box-shadow: 0 0 15px rgba(255, 111, 97, 0.3);
        }
      `}</style>

      {/* Background Patterns */}
      <div style={{ position: 'fixed', inset: 0, zIndex: 0, overflow: 'hidden' }}>
        {patterns.map((pattern) => (
          <div
            key={pattern.id}
            className="pattern-spin"
            style={{
              position: 'absolute',
              top: `${pattern.top}%`,
              left: `${pattern.left}%`,
              width: `${pattern.size}px`,
              height: `${pattern.size}px`,
              border: `1px solid ${realms[pattern.id % realms.length].color}`,
              borderRadius: '50%',
              opacity: pattern.opacity,
              transform: `rotate(${pattern.rotation}deg)`,
            }}
          />
        ))}
      </div>

      {/* Header */}
      <header
        style={{
          position: 'relative',
          zIndex: 1,
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: '1rem',
          borderBottom: '1px solid #ff6f61',
          backgroundColor: darkMode ? 'rgba(0, 20, 0, 0.7)' : 'rgba(240, 240, 240, 0.8)',
          backdropFilter: 'blur(5px)',
        }}
      >
        <h1
          style={{
            fontSize: '2.5rem',
            fontWeight: 'bold',
            margin: 0,
            display: 'flex',
            alignItems: 'center',
            gap: '0.5rem',
            textShadow: darkMode ? '0 0 10px #ff6f61' : 'none',
          }}
        >
          <span className={showGlitchEffect ? 'glitch' : ''}>GROUP_MASTER</span>
          <span style={{ fontSize: '1rem', opacity: 0.7 }}>v1.0</span>
        </h1>
        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
          {gameStarted && (
            <>
              <div className="pulse-glow" style={{ padding: '0.5rem 1rem', border: '1px solid #ff6f61' }}>
                THM: {theorems}
              </div>
              <div style={{ padding: '0.5rem 1rem', border: '1px solid #88b04b' }}>
                PRF: {proofs}
              </div>
            </>
          )}
          <button onClick={toggleTheme} className="neo-button" style={{ width: '40px', height: '40px' }}>
            {darkMode ? '☀️' : '🌙'}
          </button>
        </div>
      </header>

      {/* Notification */}
      {showNotification && (
        <div
          style={{
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(0, 20, 0, 0.9)',
            color: '#ff6f61',
            padding: '1rem 2rem',
            borderRadius: '4px',
            zIndex: 100,
            textAlign: 'center',
            fontSize: '1.5rem',
            border: '1px solid #ff6f61',
            boxShadow: '0 0 20px rgba(255, 111, 97, 0.5)',
            animation: 'pulse-glow 2s infinite',
          }}
        >
          {notificationMessage}
        </div>
      )}

      {/* Main Content */}
      <main style={{ maxWidth: '1200px', margin: '0 auto', padding: '2rem 1rem', position: 'relative', zIndex: 1 }}>
        {/* Tutorial */}
        {showTutorial && gameStarted && (
          <div
            style={{
              position: 'fixed',
              bottom: '2rem',
              left: '50%',
              transform: 'translateX(-50%)',
              width: '80%',
              maxWidth: '600px',
              backgroundColor: 'rgba(0, 20, 0, 0.9)',
              borderRadius: '4px',
              padding: '1.5rem',
              border: '1px solid #ff6f61',
              boxShadow: '0 0 15px rgba(255, 111, 97, 0.3)',
              zIndex: 100,
            }}
          >
            <div style={{ display: 'flex', gap: '1rem', alignItems: 'flex-start' }}>
              <div style={{ fontSize: '1.8rem' }}>{tutorialSteps[tutorialStep].character === 'ai' ? '🤖' : '🧑‍🏫'}</div>
              <div>
                <div style={{ marginBottom: '0.5rem', opacity: 0.7 }}>
                  {tutorialSteps[tutorialStep].character === 'ai' ? 'AI' : username.toUpperCase()}
                </div>
                <div>{tutorialSteps[tutorialStep].text}</div>
              </div>
            </div>
            <button onClick={nextTutorialStep} className="neo-button" style={{ marginTop: '1rem', alignSelf: 'flex-end' }}>
              {tutorialStep < tutorialSteps.length - 1 ? 'NEXT' : 'BEGIN'}
            </button>
          </div>
        )}

        {!gameStarted ? (
          // Login Screen
          <div style={{ textAlign: 'center', maxWidth: '600px', margin: '0 auto' }}>
            <h2 style={{ fontSize: '2.5rem', marginBottom: '1rem', textTransform: 'uppercase' }}>
              GroupMaster Terminal
            </h2>
            <p style={{ fontSize: '1rem', marginBottom: '2rem', opacity: 0.7 }}>
              UNRAVEL THE MYSTERIES OF GROUP THEORY.<br />
              ALL PROGRESS IS RECORDED.
            </p>
            <div className="neo-card">
              <h3 style={{ marginBottom: '1rem' }}>Mathematician Registration</h3>
              <input
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                placeholder="Your Name"
                style={{
                  backgroundColor: 'rgba(0, 20, 0, 0.7)',
                  color: '#ff6f61',
                  border: '1px solid #ff6f61',
                  padding: '0.75rem',
                  width: '100%',
                  marginBottom: '1rem',
                  fontSize: '1.2rem',
                  textAlign: 'center',
                }}
                maxLength={15}
              />
              <div style={{ marginBottom: '1.5rem' }}>
                <p style={{ marginBottom: '1rem' }}>Select Avatar</p>
                <div style={{ display: 'flex', justifyContent: 'center', gap: '1rem' }}>
                  {renderAvatar('scholar', 50)}
                  {renderAvatar('robot', 50)}
                  {renderAvatar('book', 50)}
                  {renderAvatar('equation', 50)}
                </div>
              </div>
              <button onClick={startGame} className="neo-button" style={{ padding: '0.75rem 2rem', fontSize: '1.25rem' }}>
                Enter Realm
              </button>
            </div>
          </div>
        ) : (
          // Game Interface
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(350px, 1fr))', gap: '1.5rem' }}>
            {/* Realm Selection */}
            <div className="neo-card">
              <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                <span>🧮</span> Realms
              </h2>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                {realms.map((realm, index) => (
                  <button
                    key={index}
                    onClick={() => theorems >= realm.theoremsRequired && setActiveRealm(index)}
                    className={`hover-effect ${index === activeRealm ? 'pulse-glow' : ''}`}
                    style={{
                      backgroundColor: index === activeRealm ? 'rgba(0, 20, 0, 0.8)' : 'transparent',
                      color: theorems >= realm.theoremsRequired ? realm.color : '#666',
                      border: `1px solid ${realm.color}`,
                      padding: '0.75rem',
                      fontWeight: 'bold',
                      cursor: theorems >= realm.theoremsRequired ? 'pointer' : 'not-allowed',
                      opacity: theorems >= realm.theoremsRequired ? 1 : 0.5,
                    }}
                  >
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <div style={{ display: 'flex', gap: '0.5rem' }}>
                        <span>{realm.icon}</span>
                        <span>{realm.name}</span>
                      </div>
                      <span>{realmsVisited.includes(index) ? '✓' : ''}</span>
                    </div>
                    <div style={{ fontSize: '0.8rem', opacity: 0.7 }}>
                      {realm.description} {theorems < realm.theoremsRequired ? `(Requires ${realm.theoremsRequired} THM)` : ''}
                    </div>
                  </button>
                ))}
              </div>
              <div style={{ marginTop: '1rem', padding: '0.75rem', border: '1px solid #ff6f61' }}>
                <p style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>💡 Group Theory Tip:</p>
                <p>{groupTips[currentTip]}</p>
              </div>
            </div>

            {/* Active Realm Content */}
            <div className="neo-card">
              <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', color: realms[activeRealm].color, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                <span>{realms[activeRealm].icon}</span> {realms[activeRealm].name}
              </h2>
              {puzzleActive && currentPuzzle ? (
                <div>
                  <div style={{ marginBottom: '1rem' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                      <div>Puzzle: <span style={{ color: realms[activeRealm].color }}>{currentPuzzle.name}</span></div>
                      <div>{currentPuzzle.difficulty}</div>
                    </div>
                    <div style={{ marginBottom: '1rem' }}>
                      <div style={{ fontSize: '0.8rem', marginBottom: '0.25rem' }}>Insight</div>
                      <div className="progress-bar">
                        <div className="progress-bar-fill" style={{ width: `${insight}%`, backgroundColor: '#ff6f61' }}></div>
                      </div>
                    </div>
                    <div className="puzzle-grid">
                      {puzzleGrid.map((row, rowIndex) =>
                        row.map((cell, colIndex) => (
                          <div
                            key={`${rowIndex}-${colIndex}`}
                            className="grid-cell"
                            style={{
                              backgroundColor: cell.revealed ? (cell.correct ? 'rgba(136, 176, 75, 0.3)' : 'rgba(255, 111, 97, 0.3)') : '#111',
                              border: selectedCell?.row === rowIndex && selectedCell?.col === colIndex ? '2px solid #ff6f61' : '1px solid #333',
                            }}
                            onClick={() => handleGridInteraction(rowIndex, colIndex)}
                          >
                            {cell.revealed ? cell.value : '?'}
                          </div>
                        ))
                      )}
                    </div>
                  </div>
                  <button
                    onClick={() => {
                      setPuzzleActive(false);
                      if (puzzleTimeout) clearTimeout(puzzleTimeout);
                      addTerminalEntry('Puzzle aborted.');
                    }}
                    className="neo-button"
                    style={{ width: '100%', backgroundColor: 'rgba(255, 111, 97, 0.1)', borderColor: '#ff6f61', color: '#ff6f61' }}
                  >
                    Abort Puzzle
                  </button>
                </div>
              ) : (
                <div>
                  <div style={{ padding: '1rem', border: '1px solid #ff6f61', marginBottom: '1rem' }}>
                    <p>{realms[activeRealm].description}</p>
                  </div>
                  <h3 style={{ marginBottom: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    <span>🎯</span> Puzzles
                  </h3>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                    {puzzles[activeRealm].map((puzzle) => (
                      <div key={puzzle.id} className="neo-card" style={{ opacity: puzzle.completed ? 0.7 : 1 }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.25rem' }}>
                          <div style={{ fontWeight: 'bold', color: realms[activeRealm].color }}>{puzzle.name}</div>
                          <div style={{ fontSize: '0.8rem', backgroundColor: 'rgba(0, 20, 0, 0.5)', padding: '0.25rem 0.5rem', borderRadius: '4px' }}>
                            {puzzle.difficulty}
                          </div>
                        </div>
                        <div style={{ fontSize: '0.9rem', marginBottom: '0.5rem', opacity: 0.7 }}>
                          {puzzle.type === 'closure' ? 'Verify closure property' :
                           puzzle.type === 'identity' ? 'Find the identity element' :
                           puzzle.type === 'inverse' ? 'Locate an inverse' :
                           'Complete the operation table'}
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <div style={{ fontSize: '0.8rem' }}>
                            Rewards: <span style={{ color: '#ff6f61' }}>{puzzle.theoremReward} THM</span>, <span style={{ color: '#88b04b' }}>{puzzle.proofReward} PRF</span>
                          </div>
                          {puzzle.completed ? (
                            <div style={{ color: '#ff6f61' }}>✓ SOLVED</div>
                          ) : (
                            <button
                              onClick={() => puzzle.insightRequired <= insight && startPuzzle(puzzle)}
                              className="neo-button"
                              style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', opacity: puzzle.insightRequired > insight ? 0.5 : 1 }}
                              disabled={puzzle.insightRequired > insight}
                            >
                              SOLVE
                            </button>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                  <button onClick={() => setShowTerminal(true)} className="neo-button" style={{ marginTop: '1rem', width: '100%' }}>
                    TERMINAL
                  </button>
                </div>
              )}

              {/* Terminal */}
              {showTerminal && (
                <div style={{ position: 'fixed', inset: 0, backgroundColor: 'rgba(0, 20, 0, 0.9)', zIndex: 50, padding: '2rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1rem', borderBottom: '1px solid #ff6f61' }}>
                    <div>TERMINAL@{username.toUpperCase()}</div>
                    <button onClick={() => setShowTerminal(false)} className="neo-button" style={{ backgroundColor: 'transparent', borderColor: '#ff6f61', color: '#ff6f61' }}>
                      CLOSE
                    </button>
                  </div>
                  <div className="terminal-window" style={{ flex: 1 }}>
                    {terminalHistory.map((entry, i) => (
                      <div key={i} style={{ marginBottom: '0.25rem', color: entry.isCommand ? '#88b04b' : '#ff6f61' }}>
                        <span style={{ opacity: 0.7 }}>[{entry.timestamp}]</span> {entry.text}
                      </div>
                    ))}
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                    <div>$</div>
                    <input
                      type="text"
                      value={terminalInput}
                      onChange={(e) => setTerminalInput(e.target.value)}
                      className="terminal-input"
                      autoFocus
                      style={{ flex: 1 }}
                    />
                    <span className="terminal-cursor">█</span>
                  </div>
                </div>
              )}
            </div>

            {/* Tools & Stats */}
            <div className="neo-card">
              <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                <span>🔧</span> Mathematical Tools
              </h2>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                {tools.map((tool) => (
                  <div key={tool.id} className="neo-card" style={{ opacity: tool.unlocked ? 1 : 0.5 }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.25rem' }}>
                      <div style={{ fontWeight: 'bold' }}>{tool.name}</div>
                      <div style={{ fontSize: '0.8rem', backgroundColor: 'rgba(0, 20, 0, 0.5)', padding: '0.25rem 0.5rem' }}>
                        Lvl {tool.level}
                      </div>
                    </div>
                    <div style={{ fontSize: '0.9rem', marginBottom: '0.5rem', opacity: 0.7 }}>{tool.description}</div>
                    {tool.unlocked ? (
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <div style={{ fontSize: '0.8rem' }}>Cost: {tool.cost * tool.level} PRF</div>
                        <button
                          onClick={() => upgradeTool(tool.id)}
                          className="neo-button"
                          style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', opacity: proofs >= tool.cost * tool.level ? 1 : 0.5 }}
                          disabled={proofs < tool.cost * tool.level}
                        >
                          UPGRADE
                        </button>
                      </div>
                    ) : (
                      <div style={{ fontSize: '0.8rem', color: '#ff6f61' }}>LOCKED - Gain more theorems</div>
                    )}
                  </div>
                ))}
              </div>

              <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', marginTop: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                <span>🏆</span> Achievements
              </h2>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                {achievements.map((achievement) => (
                  <div
                    key={achievement.id}
                    style={{
                      backgroundColor: achievement.unlocked ? 'rgba(255, 111, 97, 0.1)' : 'rgba(0, 20, 0, 0.5)',
                      padding: '0.75rem',
                      borderRadius: '4px',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '0.75rem',
                      opacity: achievement.unlocked ? 1 : 0.6,
                    }}
                  >
                    <div
                      style={{
                        width: '32px',
                        height: '32px',
                        borderRadius: '50%',
                        backgroundColor: achievement.unlocked ? '#ff6f61' : '#333',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                      }}
                    >
                      {achievement.unlocked ? '✓' : '?'}
                    </div>
                    <div>
                      <div style={{ fontWeight: 'bold' }}>{achievement.name}</div>
                      <div style={{ fontSize: '0.8rem' }}>{achievement.description}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}
      </main>
    </div>
  );
};

export default GroupMaster;
```

### How to Play
1. **Start:** Enter your name and choose an avatar to begin with 10 Theorems (THM) and 50 Proofs (PRF).
2. **Explore Realms:** Select a realm (group) like Z/4Z or S3, unlocked by earning theorems.
3. **Solve Puzzles:** Start a puzzle (e.g., "Closure Test"), interact with a 4x4 grid to reveal elements, and ensure they satisfy group properties. Insight depletes with each move, enhanced by tool levels.
   - **Closure:** Reveal elements that form a closed set.
   - **Identity:** Find the identity element (e.g., '0' or 'e').
   - **Inverse:** Match an element with its inverse.
   - **Table:** Fill in a group operation table (simplified for Z/4Z).
4. **Upgrade Tools:** Use Proofs to level up tools, reducing insight cost and improving efficiency.
5. **Earn Achievements:** Unlock milestones like "First Theorem" or "Group Legend."

### Debugging Notes
- **Type Safety:** All state variables and functions are typed with TypeScript interfaces, preventing runtime errors (e.g., `Puzzle`, `GridCell`).
- **Null Checks:** Added checks for `currentPuzzle` and `puzzleTimeout` to avoid undefined errors.
- **Grid Logic:** Simplified group operations (e.g., Z/4Z table uses modulo 4) to ensure solvability within the grid size.
- **Event Handlers:** Properly scoped with `useCallback` and cleaned up with `useEffect` for keyboard events.
- **CSS:** Scoped with `<style jsx>` to avoid global conflicts, using TypeScript-compatible syntax.

### Educational Value
- **Closure:** Players learn that a group operation must produce an element within the set.
- **Identity:** Identifies the element that doesn’t change others (e.g., 0 in Z/4Z).
- **Inverse:** Teaches pairing elements that cancel each other (e.g., 1 and 3 in Z/4Z).
- **Operation Table:** Visualizes group structure, reinforcing associativity and symmetry.

This game combines fun, interactive gameplay with a solid introduction to group theory, fully debugged and ready to run in a TypeScript environment!